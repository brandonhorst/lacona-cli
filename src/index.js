#! /usr/bin/env node

const _ = require('lodash')
const os = require('os')
const path = require('path')
const commander = require('commander')
const fs = require('fs')
const childProcess = require('child_process')
const inquirer = require('inquirer')
const npmSafeName = require('npm-safe-name')
const jsonfile = require('jsonfile')
const request = require('request')
const tarPack = require('tar-pack')
const fstream = require('fstream')
const FstreamNPM = require('fstream-npm')
const rimraf = require('rimraf')
const updateNotifier = require('update-notifier')
const userHome = require('user-home')
const defaults = require('./defaults')

const cliPackage = require('../package.json')

updateNotifier({pkg: cliPackage, updateCheckInterval: 1000 * 60 * 60}).notify()

const userCommandsDir = path.join(os.homedir(), 'Library/Application Support/Lacona/Addons')

const pkg = fs.existsSync('./package.json') ? jsonfile.readFileSync('./package.json') : {}
const pkgLacona = pkg.lacona || {}

function getDefaultDotIgnore (...additional) {
  return `# Logs
logs
*.log
npm-debug.log*

# Runtime data
pids
*.pid
*.seed

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules
jspm_packages

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Additional Lacona ignores
${additional.join('\n')}
`
}

function generateExtensionsSourceTranspile (results) {
  if (results.type === 'command') {
    return `/** @jsx createElement */
import { createElement } from 'elliptical'
import { Command } from 'lacona-phrases'
import { runApplescript } from 'lacona-api'

export const MyNewCommand = {
  extends: [Command],

  execute (result) {
    console.log('executing MyNewCommand')
    runApplescript({script: \`display alert "$\{result\}"\`})
  },

  describe (${results.config ? '{config}' : ''}) {
    return (
      <literal
        text='test my new command'
        value=${results.config
          ? `{config.${configify(results.name)}.message}`
          : "'Hello, world!'"} />
    )
  }
}

export const extensions = [MyNewCommand]
`
  } else { // extension
    return `/** @jsx createElement */
import { createElement } from 'elliptical'
import { URL } from 'lacona-phrases'

export const MyNewExtension = {
  extends: [URL],

  describe (${results.config ? '{config}' : ''}) {
    return (
      <literal
        text='my homepage'
        value=${results.config
          ? `{config.${configify(results.name)}.homepage}`
          : "'http://lacona.io'"} />
    )
  }
}

export const extensions = [MyNewExtension]
`
  }
}

function generateExtensionsSource (results) {
  if (results.type === 'command') {
    return `const elliptical = require('elliptical')
const laconaPhrases = require('lacona-phrases')
const laconaAPI = require('lacona-api')

const literal = elliptical.createElement.bind(null, 'literal')

const MyNewCommand = {
  extends: [laconaPhrases.Command],

  execute (result) {
    console.log('executing MyNewCommand')
    laconaAPI.runApplescript({script: \`display alert "$\{result\}"\`})
  },

  describe (${results.config ? 'model' : ''}) {
    return literal({
      text: 'test my new command',
      value: ${results.config
        ? `model.config.${configify(results.name)}.message`
        : "'http://lacona.io'"}
    })
  }
}

exports.extensions = [MyNewCommand]
`
  } else { // extension
    return `const elliptical = require('elliptical')
const laconaPhrases = require('lacona-phrases')

const literal = elliptical.createElement.bind(null, 'literal')

const MyNewExtension = {
  extends: [laconaPhrases.URL],

  describe (${results.config ? 'model' : ''}) {
    return literal({
      text: 'my homepage',
      value: ${results.config
        ? `model.config.${configify(results.name)}.homepage`
        : "'http://lacona.io'"}
    })
  }
}

exports.extensions = [MyNewExtension]
`
  }
}

function generateConfig (results) {
  if (results.config && results.type === 'command') {
    return {
      [configify(results.name)]: {
        title: results.title,
        type: 'object',
        properties: {
          message: {
            title: 'Alert message',
            type: 'string',
            default: 'Hello, world!'
          }
        }
      }
    }
  } else if (results.config && results.type === 'extension') {
    return {
      [configify(results.name)]: {
        title: results.title,
        type: 'object',
        properties: {
          homepage: {
            title: 'Homepage URL',
            type: 'string',
            default: 'http://lacona.io'
          }
        }
      }
    }
  } else {
    return {}
  }
}

function generatePackageJson (existing, results) {
  const npmDesc = results.description
    ? `Lacona Addon to ${results.description}`
    : undefined
  return _.assign({}, existing, {
    name: results.name,
    version: existing.version || results.version || '1.0.0',
    description: existing.description || npmDesc,
    main: existing.main || results.transpile
      ? 'lib/index.js'
      : 'index.js',
    lacona: _.assign({}, existing.lacona, {
      title: results.title,
      description: results.description,
      config: existing.config || 'config.json'
    }),
    scripts: existing.scripts || (results.transpile
      ? {
        build: 'babel src --out-dir lib',
        clean: 'rimraf lib',
        prepublish: 'npm run clean && npm run build'
      } : {}
    ),
    keywords: existing.keywords || [
      'lacona',
      'lacona-addon'
    ],
    license: results.license,
    repository: existing.repository || (results.repo
      ? {
        type: 'git',
        url: results.repo
      } : undefined
    ),
    dependencies: existing.dependencies || {
      'lacona-phrases': '^1.0.0',
      'lacona-api': '^1.0.0',
      'elliptical': '^1.0.0'
    },
    devDependencies: existing.devDependencies || (results.transpile
      ? {
        'babel-plugin-transform-react-jsx': '^6.0.0',
        'babel-preset-es2015': '^6.0.0',
        'babel-cli': '^6.0.0',
        'rimraf': '^2.0.0'
      } : {}
    ),
    babel: existing.babel || (
      results.transpile
        ? {
          presets: ['es2015'],
          plugins: ['transform-react-jsx']
        } : undefined
    )
  })
}

function npmify (title) {
  return _.kebabCase(_.deburr(title))
}

function configify (name) {
  if (_.startsWith(name, 'lacona-')) {
    return _.camelCase(name.slice(7))
  } else {
    return _.camelCase(name)
  }
}

// translated to sync from
// https://github.com/npm/init-package-json/blob/master/default-input.js
function defaultGitRepo () {
  let gconf
  try {
    gconf = fs.readFileSync('.git/config', 'utf8')
  } catch (e) {
    return
  }

  if (!gconf) {
    return
  }

  const confLines = gconf.split(/\r?\n/)
  let i = confLines.indexOf('[remote "origin"]')
  let u
  if (i !== -1) {
    u = gconf[i + 1]
    if (!u.match(/^\s*url =/)) u = gconf[i + 2]
    if (!u.match(/^\s*url =/)) u = null
    else u = u.replace(/^\s*url = /, '')
  }

  if (u && u.match(/^git@github.com:/)) {
    u = u.replace(/^git@github.com:/, 'https://github.com/')
  }
  return u
}

function writeDotFile (filename, ...additions) {
  const source = getDefaultDotIgnore(...additions)
  safeWriteFileSync(filename, source)
}

function maybeAppendDotFile (filename, ...additions) {
  const existing = fs.readFileSync(filename, {encoding: 'utf8'})
  const toAppend = []
  for (let addition of additions) {
    const regex = `^\\s*${addition}\\s*$`
    if (!(new RegExp(regex, 'm')).test(existing)) {
      toAppend.push(addition)
    }
  }

  if (toAppend.length > 0) {
    const newSource = `${existing}

# Lacona Additions
${toAppend.join('\n')}
`
    console.log(`Modifying existing ignore file ${filename}`)
    fs.writeFileSync(filename, newSource)
  }
}

function init (callback) {
  return inquirer.prompt([{
    name: 'title',
    message: 'Addon Title [for humans]:',
    default: pkgLacona.title
  }, {
    name: 'name',
    message: 'Package Name [for npm]:',
    validate: (title) => {
      return npmSafeName(npmify(title))
        ? true
        : 'Name must be a valid npm package name'
    },
    default: (results) => {
      if (pkg.name) {
        return pkg.name
      } else {
        const npmified = npmify(results.title)
        if (npmSafeName(npmified)) {
          return `lacona-${npmified}`
        } else {
          return null
        }
      }
    }
  }, {
    name: 'description',
    message: 'Brief Description:',
    default: pkgLacona.description
  }, {
    name: 'type',
    type: 'list',
    message: 'Type:',
    choices: [
      {name: 'provide a new command', value: 'command', short: 'command'},
      {name: 'extend existing commands', value: 'extension', short: 'extension'}
    ],
    when: () => {
      return !fs.existsSync('./index.js') && !fs.existsSync('./src/index.js')
    }
  }, {
    name: 'config',
    type: 'confirm',
    message: 'Include User Preferences?',
    when: () => !pkgLacona.config
  }, {
    name: 'transpile',
    type: 'confirm',
    default: true,
    message: 'Use Transpilation? [recommended]',
    when: () => !fs.existsSync('./index.js') && !fs.existsSync('./src/index.js')
  }, {
    name: 'repo',
    message: 'git repository:',
    default: defaultGitRepo,
    when: () => !pkg.repository
  }, {
    name: 'license',
    message: 'license:',
    default: 'MIT',
    when: () => !pkg.license
  }, {
    name: 'version',
    message: 'version:',
    default: '1.0.0',
    when: () => !pkg.version
  }, {
    name: 'confirm',
    type: 'confirm',
    default: true,
    message: 'Look good?'
  }]).then((obj) => {
    try {
      if (obj.confirm) {
        const newPackage = generatePackageJson(pkg, obj)
        jsonfile.writeFileSync('./package.json', newPackage, {spaces: 2})

        if (obj.type) {
          if (obj.transpile) {
            const source = generateExtensionsSourceTranspile(obj)
            fs.mkdirSync('./src')
            safeWriteFileSync('./src/index.jsx', source)

            if (!fs.existsSync('./.gitignore')) {
              writeDotFile('./.gitignore', 'lib')
            } else {
              maybeAppendDotFile('./.gitignore', 'lib')
            }

            if (!fs.existsSync('./.npmignore')) {
              writeDotFile('./.npmignore', 'src')
            } else {
              maybeAppendDotFile('./.npmignore', 'src')
            }
          } else {
            const source = generateExtensionsSource(obj)
            safeWriteFileSync('./index.js', source)

            if (!fs.existsSync('./.gitignore')) {
              const gitignoreSource = getDefaultDotIgnore()
              safeWriteFileSync('./.gitignore', gitignoreSource)
            }
          }
        }
        if (!_.isUndefined(obj.config)) {
          const newConfig = generateConfig(obj)
          safeWriteFileSync('./config.json', newConfig, {spaces: 2}, jsonfile)
        }
      }
    } catch (e) {
      console.log(`Error occurred: ${e}`)
    }
  })
}

function safeWriteFileSync (filename, content, options = {}, pkg = fs) {
  if (fs.existsSync(filename)) {
    console.log(`Refusing to overwrite existing ${filename}`)
  } else {
    pkg.writeFileSync(filename, content, options)
  }
}

function reload () {
  console.log('Reloading Lacona Addons')

  try {
    childProcess.execSync('osascript -e \'tell application "Lacona" to reload addons\'', {encoding: 'utf8'})
  } catch (e) {
    console.log(`ERROR: reload addons osascript failed: ${e}`)
    return
  }
}

function ls () {
  try {
    const addons = defaults.readSync('io.lacona.Lacona', 'addons')
    _.forEach(addons, addon => console.log(addon))
  } catch (e) {} // noop - does not exist is fine
}

function addToAddons (packageName) {
  let addons
  try {
    addons = defaults.readSync('io.lacona.Lacona', 'addons')
  } catch (e) {
    addons = []
  }
  const index = _.findIndex(addons, {name: packageName})
  if (index !== -1) {
    return true
  } 
  console.log(`Adding ${packageName} to the Lacona settings`)
  addons.push({name: packageName, enabled: true})
  try {
    defaults.writeSync('io.lacona.Lacona', 'addons', addons)
  } catch (e) {
    console.error('Error writing Lacona settings', e)
    return false
  }
  console.log(`Successfully added ${packageName} to the Lacona settings`)
  return true
}

function removeFromAddons (packageName) {
  console.log(`Removing ${packageName} from the Lacona settings`)
  let addons
  try {
    addons = defaults.readSync('io.lacona.Lacona', 'addons')
  } catch (e) {
    addons = []
  }
  const index = _.findIndex(addons, {name: packageName})
  if (index === -1) {
    console.log(`${packageName} was not found in Lacona settings`)
    return true
  }

  addons.splice(index, 1)

  try {
    defaults.writeSync('io.lacona.Lacona', 'addons', addons)
  } catch (e) {
    console.error('Error writing Lacona settings', e)
    return false
  }
  console.log(`Successfully added ${packageName} to the Lacona settings`)
  return true
}

function npmInstall (packageOrPath) {
  console.log(`Installing dependencies via npm`)
  try {
    childProcess.execSync('npm install', {encoding: 'utf8'})
  } catch (e) {
    console.log(`ERROR: npm install failed: ${e}`)
    return false
  }

  console.log(`Installing ${packageOrPath} via npm`)
  try {
    childProcess.execSync(`npm install ${packageOrPath}`, {
      encoding: 'utf8',
      cwd: userCommandsDir
    })
  } catch (e) {
    console.log(`ERROR: npm install ${packageOrPath} failed: ${e}`)
    return false
  }
  console.log(`Successfully installed ${packageOrPath} via npm`)
  return true
}

function npmUninstall (packageName) {
  console.log(`Uninstalling ${packageName} via npm`)
  try {
    childProcess.execSync(`npm uninstall ${packageName}`, {
      encoding: 'utf8',
      cwd: userCommandsDir
    })
  } catch (e) {
    console.log(`ERROR: npm uninstall failed: ${e}`)
    return false
  }
  console.log(`Successfully uninstalled ${packageName} via npm`)
  return true
}


function install (packageName) {
  if (!packageName) {
    npmInstall(process.cwd()) && addToAddons(pkg.name) && setDevMode(pkg.name)
  } else { // package name provided
    npmInstall(packageName) && addToAddons(packageName) && setDevMode(packageName)
  }
}

function uninstall (packageName = pkg.name) {
  npmUninstall(packageName) && removeFromAddons(packageName) && reload()
}

function logs () {
  const logPath = path.join(userHome, 'Library/Logs/Lacona/app.log')
  try {
    const content = fs.readFileSync(logPath, {encoding: 'utf8'})
    console.log(content)
  } catch (e) {
    console.error(`Log file not found: ${e}`)
  }
}

function setDevMode (packageName = pkg.name) {
  defaults.writeSync('io.lacona.Lacona', 'devModeAddon', packageName)
  console.log(`Setting developer mode for ${packageName}`)
  reload()
}

commander
  .version(pkg.version)

commander
  .command('init')
  .description('initialize a new Lacona command in this directory')
  .action(init)

commander
  .command('install [package]')
  .description('install the specified package (or the current directory)')
  .action(install)

commander
  .command('logs')
  .description('view the system logs about Lacona')
  .action(logs)

commander
  .command('ls')
  .description('list installed packages')
  .action(ls)

commander
  .command('reload')
  .description('reload the Lacona addon cache')
  .action(reload)

commander
  .command('uninstall [package]')
  .description('uninstall the specified package (or the current directory)')
  .action(uninstall)

commander
  .command('dev [package]')
  .description('enable developer mode (remove delay) for the specified package (or the current directory)')
  .action(setDevMode)

commander.parse(process.argv)

if (!process.argv.slice(2).length) {
  commander.outputHelp()
}
